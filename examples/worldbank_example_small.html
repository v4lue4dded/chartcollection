<!DOCTYPE html>
<html lang="en">

<head>
    <title>World Bank Crossfilter Example</title>
    <meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Dependencies -->
    <script src="lib/d3.js"></script>
    <script src="lib/crossfilter.js"></script>
    <script src="lib/promise.js"></script>

    <!-- C3 -->
    <link rel="stylesheet" href="../css/c3.css" />
    <script src="../js/c3.js"></script>
    <script src="../js/c3-table.js"></script>
    <script src="../js/c3-plot.js"></script>
    <script src="../js/c3-layers.js"></script>
    <script src="../js/c3-legend.js"></script>

    <!-- Styles -->
    <style>
        body {
            overflow-y: scroll;
            font-family: sans-serif;
        }

        /* Table Styles */
        table {
            border-collapse: collapse;
        }

        .c3.table {
            border: 1px solid black;
            font-family: sans-serif;
        }

        .c3.table th {
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            padding: 0.25em;
            border: 1px solid black;
            border-bottom: 2px solid black;
            background-color: lightgray;
        }

        .c3.table caption {
            border: 1px solid black;
        }

        .c3.table tr {
            background-color: white;
        }

        .c3.table tr:nth-child(2n) {
            background-color: whitesmoke;
        }

        .c3.table th.sorted {
            background-color: steelblue;
        }

        .c3.table tr.selected {
            background-image: linear-gradient(#ffeda0, #f9da4d);
        }

        .c3.table tr.deselected:not(:hover) {
            opacity: 0.4;
        }

        .c3.table.selectable tr.hover {
            background-color: wheat;
        }

        .c3.table td {
            text-align: center;
            border-left: 1px solid black;
            border-right: 1px solid black;
            padding: 0.25em;
        }

        .c3.table td.sorted {
            background-color: rgba(128, 128, 128, 0.1);
        }
    </style>
</head>

<body>

    <span id="waiting"><b>Loading World Bank Data...</b></span>

    <main style="display:none">
        <div id="worldbank_year_table"></div>
        <div id="worldbank_region_table"></div>
        <div id="worldbank_country_table"></div>
    </main>
    <script>
        // # C3 Crossfilter Dataset
        // _An example the includes many plots and tables synchronized with a common dataset using [**Crossfilter **][Crossfilter]._
        // _This example also includes more demonstration on how to style and extend custom charts._
        // [Crossfilter]: http://square.github.io/crossfilter/ "Crossfilter Library"
        //
        // Crossfilter is a great library for managing large multivariate datasets and filtering on multiple dimensions.
        // To keep things simple this example doesn't use
        // a proper _MVC_ architecture, so we'll just use some simple global objects:
        var gdp_data = [];
        var countries = {};
        var regions = {};
        // The following function will download the sample datasets about countries, GDP metrics, etc from **CSV files**.
        // For purposes of understanding the C3 visualization you can skip this section.  Most of it is about
        // transforming the data from the format that the **World Bank** provides to a format best suited to
        // working with the **Crossfilter** library.  We could have done this transformation ahead of time and
        // just used that modified CSV, but I wanted to work with the CSV in the original format to be able to
        // update the data or get new metrics from the World Bank.
        function download_data() {
            var indicator_mapping = {
                'SP.POP.TOTL': 'population',
                'EN.URB.MCTY.TL.ZS': 'urban_population',
                'NY.GDP.MKTP.CD': 'gdp',
                'NY.GDP.PCAP.CD': 'gdp_per_capita',
                'AG.LND.TOTL.K2': 'land_area',
                'NV.AGR.TOTL.CD': 'agriculture',
                'NV.IND.MANF.CD': 'manufacturing',
                'NV.SRV.TETC.CD': 'services'
            };
            // This function returns a [_promise_](http://promises-aplus.github.io/promises-spec/)
            // to easily manage multiple CSV dependencies asynchronously.
            // The user provides a callback to the promise that will exectute when the promise is _resolved_.
            // `Promise.all()` will create a promise with multiple dependencies, one for each of the three CSV files to download and process.
            return Promise.all([
                new Promise(function (resolve) {
                    // ### Load World Bank Data **CSV**
                    // Use _D3_ to download the GDP and other metrics from the **World Bank CSV** file.
                    d3.csv('data/gdp.csv')
                        // The `row` callback is used to structure what the rows look like based on the CSV data.
                        // Notice that the numerical values use a `+` to parse the string to a numerical value.
                        .row(function (row) {
                            return ({
                                country_name: row['Country Name'],
                                country_code: row['Country Code'],
                                indicator: row['Indicator Code'],
                                value: +row['Value'],
                                year: +row['Year']
                            });
                        })
                        // The `get` callback is used to process the data once it is loaded.
                        // The World Bank provides the data in a format with a single value per row.
                        // This code translates that to a format with a row for each country and year combination and
                        // a column for each additional metric provided.
                        .get(function (error, rows) {
                            var tmp_map = {};
                            for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {
                                var row_1 = rows_1[_i];
                                if (!row_1.country_code)
                                    continue;
                                var data_row = void 0;
                                if (!(data_row = tmp_map[row_1.country_code + row_1.year]))
                                    data_row = tmp_map[row_1.country_code + row_1.year] = {
                                        country_name: row_1.country_name,
                                        country_code: row_1.country_code,
                                        year: row_1.year
                                    };
                                data_row[indicator_mapping[row_1.indicator]] = row_1.value;
                            }
                            gdp_data = [];
                            for (var k in tmp_map)
                                gdp_data.push(tmp_map[k]);
                            // Convert the GDP metrics to billions of dollars for convenience and ensure
                            // GDP isn't 0 if the data is missing to avoid divide by zero problems.
                            for (var _a = 0, gdp_data_1 = gdp_data; _a < gdp_data_1.length; _a++) {
                                var record = gdp_data_1[_a];
                                for (var _b = 0, _c = ['gdp', 'agriculture', 'manufacturing', 'services']; _b < _c.length; _b++) {
                                    var metric = _c[_b];
                                    record[metric] /= 1000000000;
                                }
                                if (!record.gdp)
                                    record.gdp = 1;
                            }
                            // Resolve this promise to indicate that this dependency has been met.
                            resolve();
                        });
                }),
                // ### Load the country data **CSV**
                new Promise(function (resolve) {
                    d3.csv('data/countries.csv')
                        .row(function (row) {
                            return ({
                                name: row['name'],
                                code: row['world_bank_code'],
                                // Countries include a link to their region.
                                region_id: +row['region-code']
                            });
                        })
                        // When the raw CSV has been loaded convert it to an associative map based on country ID.
                        // Normally I found it more efficient to manage this data as an array where the index into the array cooresponds to the ID,
                        // but just keeping the example simple here.
                        .get(function (error, rows) {
                            rows.filter(function (row) { return !!row.code; }).forEach(function (row) {
                                countries[row.code] = row;
                            });
                            resolve();
                        });
                }),
                // ### Load the region info **CSV**
                // Convert it to an associative object, and resolve its promise when done.
                new Promise(function (resolve) {
                    d3.csv('data/regions.csv')
                        .row(function (row) {
                            return ({
                                name: row['name'],
                                id: +row['id'],
                                parent_id: +row['parent_id']
                            });
                        })
                        .get(function (error, rows) {
                            for (var _i = 0, rows_2 = rows; _i < rows_2.length; _i++) {
                                var row_2 = rows_2[_i];
                                regions[row_2.id] = row_2;
                            }
                            resolve();
                        });
                }),
            ]).then(function () {
                d3.selectAll('#waiting').remove();
                d3.selectAll('main').style('display', '');
                for (var _i = 0, _a = gdp_data.filter(function (record) { return !countries[record.country_code]; }); _i < _a.length; _i++) {
                    var record = _a[_i];
                    throw Error("Missing country: " + record.country_code + " - " + record.country_name);
                }
            });
        }
        // ###########################################################################
        // ## Create and Render the Charts
        // This function will create the various charts and tables for this example.
        function render() {
            // ### Prepare the data
            // Output the data set to the console if you want to take a look.
            console.log("Data:", gdp_data);
            console.log("Regions:", regions);
            console.log("Countries:", countries);
            // Setup the core metrics dataset with [**Crossfilter**](http://square.github.io/crossfilter/)
            var xf = crossfilter(gdp_data);
            // Prepare the Crossfilter **dimensions** we can filter the data on.
            // With this we can filter based on country, region, year
            // Notice the _region_ dimension is added even though the dataset doesn't link directly to
            // a region.
            var country_dim = xf.dimension(function (d) { return d.country_code; });
            var region_dim = xf.dimension(function (d) { return countries[d.country_code].region_id; });
            var year_dim = xf.dimension(function (d) { return d.year; });
            // Store an array of all the visualizations in this example.Create `redraw()` and `restyle()`
            // functions to update all of the charts in this example when the dataset is updated via _Crossfilter_.
            // C3 doesn't try to automatically update or resize charts because that can be expensive and so it
            // lets the user indicate when that needs to be done.
            var charts = [];
            function redraw() {
                for (var _i = 0, charts_redraw = charts; _i < charts_redraw.length; _i++) {
                    var chart = charts_redraw[_i];
                    chart.redraw();
                }
            }
            function restyle() {
                for (var _i = 0, charts_restyle = charts; _i < charts_restyle.length; _i++) {
                    var chart = charts_restyle[_i];
                    chart.restyle();
                }
            }
            // These variables will track the country or region the user's mouse is currently hovering over.
            var hover_country;
            var hover_region;


            function deepClone(item) {
                if (Array.isArray(item)) {
                    // Handle array
                    return item.map(deepClone);
                } else if (typeof item === 'object' && item !== null) {
                    // Handle object
                    if (typeof item.clone === 'function') {
                        // If the object has a custom clone method, use it.
                        return item.clone();
                    } else {
                        // Else, create a shallow copy and deep clone any properties
                        const clone = {};
                        for (const [key, value] of Object.entries(item)) {
                            clone[key] = deepClone(value);
                        }
                        return clone;
                    }
                } else {
                    // Primitive types can be returned directly
                    return item;
                }
            }

            function reduceAdd(p, v) {
                ++p.count;
                p.gdp += v.gdp;
                p.population += v.population;
                p.land_area += v.land_area;
                p.gdp_per_capita = p.population ? (p.gdp * 1000000000) / p.population : 0;
                return p;
            };

            function reduceRemove(p, v) {
                --p.count;
                p.gdp -= v.gdp;
                p.population -= v.population;
                p.land_area -= v.land_area;
                p.gdp_per_capita = p.population ? (p.gdp * 1000000000) / p.population : 0;
                return p;
            };

            function reduceInitial() {
                return {
                    count: 0,
                    gdp: 0,
                    gdp_per_capita: 0,
                    population: 0,
                    land_area: 0
                };
            };

            const common_columns = [
                    // Assign this column to a variable `gdp_column` so we can refer to it below for setting the default sort.
                    {
                        header: { text: "GDP" },
                        cells: { html: function (d) { return "$" + (d3.format(',')(Math.round(d.value.gdp))) + "b"; } },
                        sort: function (d) { return Math.round(d.value.gdp); },
                        vis: 'bar',
                        vis_options: {
                            styles: {
                                'background-color': 'lightsalmon'
                            }
                        }
                    }, {
                        // These columns use custom formatters to set the html content of the cell
                        // adding commas, units, rounding, etc.  You can add raw HTML if you like.
                        // These column also use the `vis` visualization support to render a bar
                        // graph based on the cell value.
                        header: { text: "Population" },
                        cells: { html: function (d) { return d3.format(',')(d.value.population); } },
                        sort: function (d) { return d.value.population; },
                        vis: 'bar',
                        vis_options: {
                            styles: {
                                'background-color': 'lightblue'
                            }
                        }
                    }, {
                        header: { text: "Land Area" },
                        cells: { html: function (d) { return (d3.format(',')(Math.round(d.value.land_area))) + "km<sup>2</sup>"; } },
                        sort: function (d) { return Math.round(d.value.land_area); },
                        vis: 'bar',
                        vis_options: {
                            styles: {
                                'background-color': 'lightgreen'
                            }
                        }
                    }, {
                        // By default, the `bar` visualization will base the bar width as a percentage of the
                        // total value of all cells.  This isn't always appropriate, though, such as in the case
                        // of GDP per capita.  So, here we manually set the `total_value` to be the maximum
                        // per capita value.  Look out for Monaco!
                        header: { text: "GDP per capita" },
                        cells: { html: function (d) { return "$" + (d3.format(',')(Math.round(d.value.gdp_per_capita))); } },
                        sort: function (d) { return Math.round(d.value.gdp_per_capita); },
                        vis: 'bar',
                        vis_options: {
                            styles: {
                                'background-color': 'lightblue'
                            }
                        }
                    },
                ]

            // ###########################################################################
            // ### year Table
            var year_data = year_dim.group().reduce(reduceAdd, reduceRemove, reduceInitial).all();
            // Create a `c3.Table` for the year table.
            var years_table;
            var gdp_column;
            charts.push(years_table = new c3.Table({
                anchor: '#worldbank_year_table',
                // Bind it to the **data** prepared above.
                // The `key`'s represent year_id`s and the `value`'s represent gdp.
                data: year_data,
                sortable: true,
                width: '100%',
                // Create two **columns** for this table.  One with the year name and another for the GDP value
                columns: [
                    {
                        // The "year" column is styled to have a background that matches the color for the
                        // year this country is in.
                        header: { text: "Year" },
                        cells: {
                            text: function (d) { return d.key; }
                        }
                    }
                ].concat(deepClone(common_columns)),
                // The initial **sort**.
                sort_column: "GDP",
                // Allow the user to **select** multiple items in the table
                selectable: 'multi',
                row_options: {
                    events: {
                        mouseenter: function () {
                            // `this` refers to the current row element in this context.
                            // Add the 'hover' class to the row when the mouse enters its area.
                            // The stylesheet then causes any table rows with
                            // the class `hover` to have a wheat-colored background.
                            this.classList.add('hover');
                        },
                        mouseleave: function () {
                            // Remove the 'hover' class from the row when the mouse leaves its area.
                            this.classList.remove('hover');
                        }
                    }
                }
            }));
            // As an alternative to declaratively setting `handlers` for the chart, you can imperatively call
            // `.on()` to manage event handlers.
            //
            // If the user **selects** one or more rows in the table, then we will
            // **filter** the data based on those years using _Crossfilter_.
            // `redraw()` is then used to update the charts based on the updated data.
            years_table.on('select', function (selections) {
                if (selections && selections.length)
                    year_dim.filter(function (key) { return selections.map(function (d) { return d.key; }).indexOf(key) >= 0; });
                else
                    year_dim.filterAll();
                redraw();
            });

            // ###########################################################################
            // ### Region Table
            var region_color = d3.scale.category10();
            var region_data = region_dim.group().reduce(reduceAdd, reduceRemove, reduceInitial).all();
            // Create a `c3.Table` for the regions table.
            var regions_table;
            var gdp_column;
            charts.push(regions_table = new c3.Table({
                anchor: '#worldbank_region_table',
                // Bind it to the **data** prepared above.
                // The `key`'s represent region_id`s and the `value`'s represent gdp.
                data: region_data,
                sortable: true,
                width: '100%',
                // Create two **columns** for this table.  One with the region name and another for the GDP value
                columns: [
                    {
                        // The "Region" column is styled to have a background that matches the color for the
                        // region this country is in.
                        header: { text: "Region" },
                        cells: {
                            text: function (d) { return regions[d.key].name; },
                            styles: {
                                'background-color': function (d) { return region_color(d.key); }
                            }

                        }
                    }
                ].concat(deepClone(common_columns)),
                // The initial **sort**.
                sort_column: "GDP",
                // Allow the user to **select** multiple items in the table
                selectable: 'multi',
                row_options: {
                    events: {
                        mouseenter: function () {
                            // `this` refers to the current row element in this context.
                            // Add the 'hover' class to the row when the mouse enters its area.
                            // The stylesheet then causes any table rows with
                            // the class `hover` to have a wheat-colored background.
                            this.classList.add('hover');
                        },
                        mouseleave: function () {
                            // Remove the 'hover' class from the row when the mouse leaves its area.
                            this.classList.remove('hover');
                        }
                    }
                }
            }));
            // As an alternative to declaratively setting `handlers` for the chart, you can imperatively call
            // `.on()` to manage event handlers.
            //
            // If the user **selects** one or more rows in the table, then we will
            // **filter** the data based on those regions using _Crossfilter_.
            // `redraw()` is then used to update the charts based on the updated data.
            regions_table.on('select', function (selections) {
                if (selections && selections.length)
                    region_dim.filter(function (key) { return selections.map(function (d) { return d.key; }).indexOf(key) >= 0; });
                else
                    region_dim.filterAll();
                redraw();
            });
            // #########################################################################################
            // ## Country Table

            var country_data = country_dim.group().reduce(reduceAdd, reduceRemove, reduceInitial).all();
            console.log("country_data", country_data);

            // Create a `c3.Table` to show the top countries
            charts.push(new c3.Table({
                anchor: '#worldbank_country_table',
                width: '100%',
                data: country_data,
                // Enable users to **select** and **sort** countries in this table.
                selectable: true,
                sortable: true,
                // **Limit** this table to only show the top 10 countries and not to display any countries
                // that have a 0 value.
                limit_rows: 10,
                filter: function (d) { return d.value.gdp > 0.000000001; },
                // Divide the table up into pages and allow user to **search** the table
                pagination: true,
                searchable: true,
                // Setup **columns** for this table
                // columns: country_columns,
                columns: [
                    {
                        header: { text: "Country" },
                        cells: { 
                            html: function (d) { return '<b>' + countries[d.key].name + '</b>';} ,
                        },
                        sort: function (d) { return countries[d.key].name ; },
                    }, {
                        // The "Region" column is styled to have a background that matches the color for the
                        // region this country is in.
                        header: { text: "Region" },
                        cells: {
                            text: function (d) { return regions[countries[d.key].region_id].name; },
                            styles: {
                                'background-color': function (d) { return region_color(countries[d.key].region_id); }
                            }
                        },
                        sort: function (d) { return regions[countries[d.key].region_id].name; },
                    },
                ].concat(deepClone(common_columns)),
                // Initial column to **sort** on.
                sort_column: "GDP",
                // Add some padding to each cell using `cell_options.styles` to assign **styles** to **cells**
                cell_options: {
                    styles: {
                        padding: "0 0.25em"
                    }
                },
                row_options: {
                    events: {
                        mouseenter: function () {
                            // `this` refers to the current row element in this context.
                            // Add the 'hover' class to the row when the mouse enters its area.
                            // The stylesheet then causes any table rows with
                            // the class `hover` to have a wheat-colored background.
                            this.classList.add('hover');
                        },
                        mouseleave: function () {
                            // Remove the 'hover' class from the row when the mouse leaves its area.
                            this.classList.remove('hover');
                        }
                    }
                },
                // `handlers` adds **event handlers** to the chart object itself.  Here we tie into the
                // `select` event when the user selects one or more row to **filter** the data on only that country.
                // _Note_: While all the other charts will filter to only display the filtered country the
                // country scatter plot will still display all countries.  This is because when you filter
                // on a particular dimension it affects all _other_ dimensinos, but _not_ the one used to filter.
                // This is actually a very good thing, otherwise when you filtered on a chart or table all
                // of the data outside of that selection would then disappear which would be awkward and hard
                // to change the selection.  If we wanted the country scatter plot to only show the filtered
                // country, the solution would be easy: just make another dimension and use different ones for
                // the scatter plot and this table.
                handlers: {
                    'select': function (selections) {
                        if (selections.length)
                            country_dim.filter(function (key) { return selections.map(function (d) { return d.key; }).indexOf(key) >= 0; });
                        else
                            country_dim.filterAll();
                        redraw();
                    }
                }
            }));
            // #########################################################################################
            // ### Initial Rendering
            // Perform the initial `render()`
            for (var _i = 0, charts_1 = charts; _i < charts_1.length; _i++) {
                var chart = charts_1[_i];
                chart.render();
            }
            // **Resize** charts if the window is resized.
            window.onresize = function () {
                for (var _i = 0, charts_4 = charts; _i < charts_4.length; _i++) {
                    var chart = charts_4[_i];
                    chart.resize();
                }
            };
        }
        // #########################################################################################
        // # Start Here
        // The loading and rendering are initiated here..  It calls the `download_data()` function to
        // download the data which returns a Promise.  We setup a _then_ callback function to be
        // called when all of the data is loaded and promised.  This callback function calls which ends up
        // calling the `render()` function.
        download_data().then(function () { setTimeout(render, 0); });
        // The reason to have setTimeout call the render function instead of calling it directly is
        // just a trick to help with debugging in the browser when using promises.  The callback function
        // for a promise is called, which catches all exceptions to be used to call an error callback.
        // This is great except unhandled errors are then reported to the debugger later after we are already
        // out of the context of the error.  So, you can't navigate the stack, view the contents of variables,
        // etc.  By using setTimeout it will cause the callback to return immediatly and then the browser
        // will call render itself.  Since this is done outside of the promise's scope, exceptions are not caught and
        // passed to the promise error handler and instead can be caught and handeled as normal in a
        // debugger.  In production code you could use this instead:
        //     download_data().then(render)
    </script>
</body>
</html>